{
  "name": "Android.flowlayout",
  "tagline": "",
  "body": "创建一个类继承ViewGroup：\r\n```\r\npublic class FlowLayout extends ViewGroup {\r\n\tpublic FlowLayout(Context context, AttributeSet attrs, int defStyle) {\r\n\t\tsuper(context, attrs, defStyle);\r\n\t\t//如果有自定义属性，在构造函数中获取\r\n\t\t// 由于我们的自定义流布局控件没有自定义属性，所以不需要获得我自定义的样式属性\r\n\t}\r\n\tpublic FlowLayout(Context context, AttributeSet attrs) {\r\n\t\tthis(context, attrs, 0);\r\n\t}\r\n\tpublic FlowLayout(Context context) {\r\n\t\tthis(context, null);\r\n\t}\r\n\t@Override\r\n\t/**\r\n\t * 设置FlowLayout的宽和高\r\n\t * 如果给的值是具体的多少dp，就直接获取宽高\r\n\t * 如果是wrap_content，则宽就铺满，高需要计算\r\n\t */\r\n\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\r\n\t\tint sizeWidth = MeasureSpec.getSize(widthMeasureSpec);\r\n\t\tint modeWidth = MeasureSpec.getMode(widthMeasureSpec);\r\n\t\tint sizeHeight = MeasureSpec.getSize(heightMeasureSpec);\r\n\t\tint modeHeight = MeasureSpec.getMode(heightMeasureSpec);\r\n\t\tint width = 0;//FlowLayout的宽\r\n\t\tint height = 0;//FlowLayout的高\r\n\t\t// 记录每一行的宽度与高度\r\n\t\tint lineWidth = 0;\r\n\t\tint lineHeight = 0;\r\n\t\t// 得到内部元素的个数\r\n\t\tint cCount = getChildCount();\r\n\t\tfor (int i = 0; i < cCount; i++) {\r\n\t\t\tView child = getChildAt(i);\r\n\t\t\t// 测量子View的宽和高\r\n\t\t\tmeasureChild(child, widthMeasureSpec, heightMeasureSpec);\r\n\t\t\t// 得到LayoutParams\r\n\t\t\tMarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();//通过lp可以拿到子控件的margin属性\r\n\t\t\t// 子View占据的宽度\r\n\t\t\tint childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;\r\n\t\t\t// 子View占据的高度\r\n\t\t\tint childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;\r\n\t\t\t// 当前行还可以放下这个子View，则不换行\r\n\t\t\tif (lineWidth + childWidth <= sizeWidth - getPaddingLeft() - getPaddingRight()) {\r\n\t\t\t\t// 叠加行宽\r\n\t\t\t\tlineWidth += childWidth;\r\n\t\t\t\t// 得到当前行子View的最大高度\r\n\t\t\t\tlineHeight = Math.max(lineHeight, childHeight);\r\n\t\t\t} else {// 换行\r\n\t\t\t\t// 对比得到最大的宽度\r\n\t\t\t\twidth = Math.max(width, lineWidth);\r\n\t\t\t\t//叠加高度\r\n\t\t\t\theight += lineHeight;\r\n\t\t\t\t// 重置新行的行宽\r\n\t\t\t\tlineWidth = childWidth;\r\n\t\t\t\t// 重置新行的行高\r\n\t\t\t\tlineHeight = childHeight;\r\n\t\t\t}\r\n\t\t\t// 最后一个控件\r\n\t\t\tif (i == cCount - 1) {\r\n\t\t\t\twidth = Math.max(lineWidth, width);\r\n\t\t\t\theight += lineHeight;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsetMeasuredDimension(\r\n\t\t\tmodeWidth == MeasureSpec.EXACTLY ? sizeWidth : width + getPaddingLeft() + getPaddingRight(),\r\n\t\t\tmodeHeight == MeasureSpec.EXACTLY ? sizeHeight : height + getPaddingTop()+ getPaddingBottom()\r\n\t\t);\r\n\t}\r\n\t//存储所有的View\r\n\tprivate List<List<View>> mAllViews = new ArrayList<List<View>>();\r\n\t//每一行的高度\r\n\tprivate List<Integer> mLineHeight = new ArrayList<Integer>();\r\n\t@Override\r\n\t/**\r\n\t * 设置View如何显示，分为两步\r\n\t * \t1.先得到所有的View（即每一行行多少个子View，有多少行）和每一行的行高\r\n\t * \t2.设置子View的位置\r\n\t */\r\n\tprotected void onLayout(boolean changed, int l, int t, int r, int b)\r\n\t{\r\n\t\tmAllViews.clear();\r\n\t\tmLineHeight.clear();\r\n\t\tint width = getWidth();// 当前FlowLayout的宽度\r\n\t\t//1.先得到所有的View（即每一行行多少个子View，有多少行）和每一行的行高\r\n\t\tint lineWidth = 0;\r\n\t\tint lineHeight = 0;\r\n\t\tList<View> lineViews = new ArrayList<View>();\r\n\t\tint cCount = getChildCount();\r\n\t\tfor (int i = 0; i < cCount; i++) {\r\n\t\t\tView child = getChildAt(i);\r\n\t\t\tMarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\r\n\t\t\tint childWidth = child.getMeasuredWidth();\r\n\t\t\tint childHeight = child.getMeasuredHeight();\r\n\t\t\t// 如果需要换行\r\n\t\t\tif (childWidth + lineWidth + lp.leftMargin + lp.rightMargin > width - getPaddingLeft() - getPaddingRight()) {\r\n\t\t\t\t// 记录LineHeight\r\n\t\t\t\tmLineHeight.add(lineHeight);\r\n\t\t\t\t// 记录当前行的Views\r\n\t\t\t\tmAllViews.add(lineViews);\r\n\t\t\t\t// 重置我们的行宽和行高\r\n\t\t\t\tlineWidth = 0;\r\n\t\t\t\tlineHeight = childHeight + lp.topMargin + lp.bottomMargin;\r\n\t\t\t\t// 重置我们的View集合\r\n\t\t\t\tlineViews = new ArrayList<View>();\r\n\t\t\t}\r\n\t\t\tlineWidth += childWidth + lp.leftMargin + lp.rightMargin;\r\n\t\t\tlineHeight = Math.max(lineHeight, childHeight + lp.topMargin + lp.bottomMargin);\r\n\t\t\tlineViews.add(child);\r\n\t\t}// for end\r\n\t\t// 处理最后一行\r\n\t\tmLineHeight.add(lineHeight);\r\n\t\tmAllViews.add(lineViews);\r\n\t\t// 2.设置子View的位置\r\n\t\tint left = getPaddingLeft();\r\n\t\tint top = getPaddingTop();\r\n\t\t// 行数\r\n\t\tint lineNum = mAllViews.size();\r\n\t\tfor (int i = 0; i < lineNum; i++) {\r\n\t\t\tlineViews = mAllViews.get(i);// 当前行的所有的View\r\n\t\t\tlineHeight = mLineHeight.get(i);//当前行的行高\r\n\t\t\t//显示每一行\r\n\t\t\tfor (int j = 0; j < lineViews.size(); j++) {\r\n\t\t\t\tView child = lineViews.get(j);\r\n\t\t\t\t// 判断child的状态，如果子View的Visibility为GONE，则不显示\r\n\t\t\t\tif (child.getVisibility() == View.GONE) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tMarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\r\n\t\t\t\t//获取子View的位置坐标（相对父控件的位置）\r\n\t\t\t\tint lc = left + lp.leftMargin;\r\n\t\t\t\tint tc = top + lp.topMargin;\r\n\t\t\t\tint rc = lc + child.getMeasuredWidth();\r\n\t\t\t\tint bc = tc + child.getMeasuredHeight();\r\n\t\t\t\t// 为子View进行布局\r\n\t\t\t\tchild.layout(lc, tc, rc, bc);\r\n\t\t\t\tleft += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;//下一个子View显示在该子View的右边\r\n\t\t\t}\r\n\t\t\t//一行显示完后,换行，回到最左边\r\n\t\t\ttop += lineHeight ;\r\n\t\t\tleft = getPaddingLeft() ;\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * 与当前ViewGroup对应的LayoutParams\r\n\t */\r\n\t@Override\r\n\tpublic LayoutParams generateLayoutParams(AttributeSet attrs) {\r\n\t\treturn new MarginLayoutParams(getContext(), attrs);\r\n\t}\r\n}\r\n```\r\n如何使用我们自定义的FlowLayout？直接在布局文件中加入FlowLayout：\r\n```\r\n<com.brokepal.flowlayout.view.FlowLayout\r\n    android:padding=\"20dp\"\r\n    android:id=\"@+id/id_flowlayout\"\r\n    android:background=\"#E5E5F5\"\r\n    android:layout_width=\"300dp\"\r\n    android:layout_height=\"wrap_content\" >\r\n</com.brokepal.flowlayout.view.FlowLayout>\r\n```\r\n在FlowLayout中加入子控件或是在Activity中动态加入控件。下面演示一下第二种方法：\r\n```\r\n@Override\r\nprotected void onCreate(Bundle savedInstanceState) {\r\n    super.onCreate(savedInstanceState);\r\n    setContentView(R.layout.activity_main);\r\n    initData();\r\n}\r\npublic void initData() {\r\n    String[] mVals = new String[]\r\n            {\r\n                    \"Hello\", \"Android\", \"Weclome Hi \", \"Button\", \"TextView\", \"Hello\",\r\n                    \"Android\", \"Weclome\", \"Button ImageView\", \"TextView\", \"Helloworld\",\r\n                    \"Android\", \"Weclome Hello\", \"Button Text\", \"TextView\"\r\n            };\r\n    LayoutInflater mInflater = LayoutInflater.from(this);\r\n    FlowLayout mFlowLayout = (FlowLayout) findViewById(R.id.id_flowlayout);\r\n    for (int i = 0; i < mVals.length; i++)\r\n    {\r\n        TextView tv = (TextView) mInflater.inflate(R.layout.tv, mFlowLayout, false);\r\n        tv.setText(mVals[i]);\r\n        mFlowLayout.addView(tv);\r\n    }\r\n}\r\n```\r\n下面是每个TextView的布局文件tv.xml：\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<TextView xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:layout_width=\"wrap_content\"\r\n    android:layout_height=\"wrap_content\"\r\n    android:layout_margin=\"5dp\"\r\n    android:background=\"@drawable/tv_bg\"\r\n    android:textColor=\"#5BC4ED\"\r\n    android:text=\"Helloworld\" >\r\n</TextView>\r\n```\r\n背景配置文件tv_bg.xml：\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\" >\r\n    <solid android:color=\"#ffffff\" />\r\n    <corners android:radius=\"30dp\" />\r\n    <padding\r\n        android:bottom=\"2dp\"\r\n        android:left=\"10dp\"\r\n        android:right=\"10dp\"\r\n        android:top=\"2dp\" />\r\n</shape>\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}